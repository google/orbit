This directory contains end-to-end tests for Orbit. The end-to-end tests use pywinauto, hence can
only be executed on Windows.

## Installing the prerequesites

We use pywinauto to remote control the Orbit UI. For each test there is a script $TestName.py in this folder.  
You need a python environment to run the automation scripts. 

Note that the use of virtual environments is recommended: 
https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/

To setup a virtual environment in Python3, run the following inside this folder:

```
python -m venv env
```

where `env` will be the name of your virtual environment and can be chosen freely. 
Next, activate the virtual environment by running:

```
.\env\Scripts\activate
```

Once you've activated the virtual environment, install the dependencies:

```
pip install absl-py
pip install psutil
pip install pywinauto
```

The script should run with python 2 and 3 so just use what you have installed. Make sure 
you are running a 64 bit version of python.
The Orbit UI is 64 bit only and pywinauto requires the bitness of python to match the bitness 
of the program under test.

*For Google internal users only:*

You can download the 
[python distribution used in the automatic test runs](https://pantheon.corp.google.com/storage/browser/_details/orbit-integration-test-data/WPy64-3830.zip;tab=live_object?project=orbitprofiler), unpack it and start 'WinPython Command Prompt.exe'. All pathes 
will be set correctly and the dependencies are installed.

## Running the tests locally

Before running an E2E test, the following conditions need to be met: 
* There needs to be a gamelet reserved 
* "hello_ggp_standalone" has to be started on the gamelet
* Orbit must be started on the local machine - either via F5 in Visual Studio or with a 
double click on Orbit.exe

To run a test, e.g. orbit_instrument_function, execute

```
python orbit_instrument_function.py
```

## Adding Tests - Tips & Tricks

### Element Names

The original names of UI elements as defined in Qt are **not** accessible through the 
testing framework. It is thus a bit tricky to find the correct elements to access. The following
tricks make your life easier:

- Use Windows Accessibility Insights https://accessibilityinsights.io/docs/en/windows/overview/
to inspect element types, names and hierarchies in Orbit
- Assign `AccessibilityName` wherever possible in Qt Designer or in code, this name is usually 
picked up as `name` in PyWinAuto

In addition, there's multiple properties on each element that can help with identification, such as
- class_name: The original name of the QT Class
- automation_id: Unique ID that, in most cases, contains the original QT Object Name. This is 
generated by concatenating all IDs up to the window root (e.g. MainWindow.TitleBar.menuExitOrbit),
so this should **not** be used in it's entirety to keep the tests as robust as possible against
UI changes. The string after the last '.' though can be used to retrieve the QT Object Name
- control_type: Type of the widget, but this is **not** the same as the QT Class Name

These properties are unfortunately not considered when using PyWinAuto's magic best_match. It is
recommended to instead use `orbit_e2e.find_control` which enables searching for those additional
identifiers. There is also a simplified version `E2ETestCase::find_control` which automatically 
searches the current application top window if no parent is specified.

Best way to find your element:
- Look at the hierarchy in Windows Accessibility Insights
- Check the control_type and name. If no name is assigned, try the automation_id
- If this combination is not globally unique, do a hierarchical lookup (e.g. find the `CaptureTab`
child of the window, and then the control you are looking for inside the capture tab), *but try to
avoid this* to keep the E2E tests robust against UI changes.

### Performance

PyWinAuto's magic best_match is *slow* for Orbit. Same is true for listing all descendants of the
main window with `descendants()`. It is a lot faster, however, if `descendants()` is restricted to
a control_type.

Again, it is recommended to use `orbit_e2e.find_control`. While this can also list
controls of all types (control_type=None), passing a control_type will result in drastically increased
performance while still allowing easy filtering.
 
### Dev Mode

Running an E2E test with the `-dev_mode` command line parameter will:
- Not close Orbit when a test is done

Use this for quick iterations on new tests. In addition, omit the usual test cases to connect to the 
stadia instance and select a process while you're developing, so you can simply keep Orbit open.

### Style

[yapf](https://github.com/google/yapf) is used with the Google style to keep consistent code style
in python files. yapf can be installed with `pip install` and will pick up the provided
`.style.yapf` file automatically. For most convenience, use yapf with an IDE extension, or run by
hand with `yapf -i <file>.py` (formats file in place).