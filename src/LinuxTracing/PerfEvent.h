// Copyright (c) 2020 The Orbit Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef LINUX_TRACING_PERF_EVENT_H_
#define LINUX_TRACING_PERF_EVENT_H_

#include <asm/perf_regs.h>
#include <linux/perf_event.h>
#include <string.h>
#include <sys/types.h>

#include <array>
#include <cstdint>
#include <memory>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "Function.h"
#include "GrpcProtos/Constants.h"
#include "KernelTracepoints.h"
#include "OrbitBase/MakeUniqueForOverwrite.h"
#include "PerfEventRecords.h"

namespace orbit_linux_tracing {

class PerfEventVisitor;

static constexpr int kNotOrderedInAnyFileDescriptor = -1;

std::array<uint64_t, PERF_REG_X86_64_MAX> perf_event_sample_regs_user_all_to_register_array(
    const perf_event_sample_regs_user_all& regs);

struct ForkPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct ExitPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct LostPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  uint64_t previous_timestamp = 0;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

// This class doesn't correspond to any event generated by perf_event_open. Rather, these events are
// produced by PerfEventProcessor. We need them to be part of the same PerfEvent hierarchy.
struct DiscardedPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  uint64_t begin_timestamp_ns;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct StackSamplePerfEvent {
  void Accept(PerfEventVisitor* visitor);

  [[nodiscard]] std::array<uint64_t, PERF_REG_X86_64_MAX> GetRegisters() {
    return perf_event_sample_regs_user_all_to_register_array(*regs);
  }
  [[nodiscard]] const char* GetStackData() const { return data.get(); }
  [[nodiscard]] uint64_t GetStackSize() { return dyn_size; }

  uint64_t timestamp;
  pid_t pid, tid;
  std::unique_ptr<perf_event_sample_regs_user_all> regs;
  uint64_t dyn_size;
  std::unique_ptr<char[]> data;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct CallchainSamplePerfEvent {
  void Accept(PerfEventVisitor* visitor);

  [[nodiscard]] const uint64_t* GetCallchain() const { return ips.get(); }
  [[nodiscard]] uint64_t GetCallchainSize() { return ips_size; }
  [[nodiscard]] std::array<uint64_t, PERF_REG_X86_64_MAX> GetRegisters() {
    return perf_event_sample_regs_user_all_to_register_array(*regs);
  }
  [[nodiscard]] const char* GetStackData() const { return data.get(); }
  void SetIps(const std::vector<uint64_t>& new_ips) {
    ips_size = new_ips.size();
    ips = make_unique_for_overwrite<uint64_t[]>(ips_size);
    memcpy(ips.get(), new_ips.data(), ips_size * sizeof(uint64_t));
  }
  [[nodiscard]] std::vector<uint64_t> CopyOfIpsAsVector() {
    return std::vector<uint64_t>(ips.get(), ips.get() + ips_size);
  }

  uint64_t timestamp;
  pid_t pid, tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  uint64_t ips_size;
  std::unique_ptr<uint64_t[]> ips;
  std::unique_ptr<perf_event_sample_regs_user_all> regs;
  std::unique_ptr<char[]> data;
};

struct UprobesPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  uint32_t cpu;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  uint64_t function_id = orbit_grpc_protos::kInvalidFunctionId;
  uint64_t sp, ip, return_address;
};

struct UprobesWithArgumentsPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  uint32_t cpu;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  uint64_t function_id = orbit_grpc_protos::kInvalidFunctionId;
  uint64_t return_address;
  perf_event_sample_regs_user_sp_ip_arguments regs;
};

struct UretprobesPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct UretprobesWithReturnValuePerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  uint64_t rax;
};

struct MmapPerfEvent {
  MmapPerfEvent(pid_t pid, uint64_t timestamp, int ordered_in_file_descriptor, uint64_t address,
                uint64_t length, uint64_t page_offset, std::string&& filename)
      : timestamp{timestamp},
        address{address},
        length{length},
        page_offset{page_offset},
        filename{filename},
        pid{pid},
        ordered_in_file_descriptor{ordered_in_file_descriptor} {}
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  uint64_t address;
  uint64_t length;
  uint64_t page_offset;
  std::string filename;
  pid_t pid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct GenericTracepointPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  uint32_t cpu;
  uint32_t size;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct TaskNewtaskPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  char comm[16];
  pid_t new_tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct TaskRenamePerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  char newcomm[16];
  pid_t renamed_tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct SchedSwitchPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  uint32_t cpu;
  pid_t prev_pid_or_minus_one;
  pid_t prev_tid;
  int64_t prev_state;
  int32_t next_tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct SchedWakeupPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t woken_tid;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
};

struct AmdgpuCsIoctlPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  uint32_t context;
  uint32_t seqno;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  std::string timeline_string;
};

struct AmdgpuSchedRunJobPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  uint32_t context;
  uint32_t seqno;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  std::string timeline_string;
};

struct DmaFenceSignaledPerfEvent {
  void Accept(PerfEventVisitor* visitor);

  uint64_t timestamp;
  pid_t pid, tid;
  uint32_t context;
  uint32_t seqno;
  int ordered_in_file_descriptor = kNotOrderedInAnyFileDescriptor;
  std::string timeline_string;
};

using PerfEvent = std::variant<
    ForkPerfEvent, ExitPerfEvent, LostPerfEvent, DiscardedPerfEvent, StackSamplePerfEvent,
    CallchainSamplePerfEvent, UprobesPerfEvent, UprobesWithArgumentsPerfEvent, UretprobesPerfEvent,
    UretprobesWithReturnValuePerfEvent, MmapPerfEvent, GenericTracepointPerfEvent,
    TaskNewtaskPerfEvent, TaskRenamePerfEvent, SchedSwitchPerfEvent, SchedWakeupPerfEvent,
    AmdgpuCsIoctlPerfEvent, AmdgpuSchedRunJobPerfEvent, DmaFenceSignaledPerfEvent>;

inline uint64_t GetTimestamp(const PerfEvent& x) {
  return std::visit([](const auto& arg) -> uint64_t { return arg.timestamp; }, x);
}

inline int GetOrderedInFileDescriptor(const PerfEvent& x) {
  return std::visit([](const auto& arg) -> uint64_t { return arg.ordered_in_file_descriptor; }, x);
}

}  // namespace orbit_linux_tracing

#endif  // LINUX_TRACING_PERF_EVENT_H_
